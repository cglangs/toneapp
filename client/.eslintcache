[{"/Users/corygallagher/Documents/node_projects/toneapp/client/src/index.js":"1","/Users/corygallagher/Documents/node_projects/toneapp/client/src/App.js":"2","/Users/corygallagher/Documents/node_projects/toneapp/client/src/reportWebVitals.js":"3","/Users/corygallagher/Documents/node_projects/toneapp/client/src/Characterbycharacter.js":"4","/Users/corygallagher/Documents/node_projects/toneapp/client/src/Fullsentence.js":"5","/Users/corygallagher/Documents/node_projects/toneapp/client/src/constants.js":"6","/Users/corygallagher/Documents/node_projects/toneapp/client/src/Header.js":"7","/Users/corygallagher/Documents/node_projects/toneapp/client/src/Login.js":"8","/Users/corygallagher/Documents/node_projects/toneapp/client/src/utils.js":"9","/Users/corygallagher/Documents/node_projects/toneapp/client/src/Learn.js":"10","/Users/corygallagher/Documents/node_projects/toneapp/client/src/Dashboard.js":"11"},{"size":1279,"mtime":1613841868591,"results":"12","hashOfConfig":"13"},{"size":1237,"mtime":1615902691849,"results":"14","hashOfConfig":"13"},{"size":362,"mtime":1611322745794,"results":"15","hashOfConfig":"13"},{"size":10770,"mtime":1616864035416,"results":"16","hashOfConfig":"13"},{"size":14604,"mtime":1615331480803,"results":"17","hashOfConfig":"13"},{"size":81,"mtime":1613073563799,"results":"18","hashOfConfig":"13"},{"size":1305,"mtime":1616860816047,"results":"19","hashOfConfig":"13"},{"size":3589,"mtime":1614093938987,"results":"20","hashOfConfig":"13"},{"size":645,"mtime":1614778703320,"results":"21","hashOfConfig":"13"},{"size":4935,"mtime":1616862882866,"results":"22","hashOfConfig":"13"},{"size":3433,"mtime":1616862196808,"results":"23","hashOfConfig":"13"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},"1dbwgo8",{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33","usedDeprecatedRules":"26"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36","usedDeprecatedRules":"26"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"26"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50","usedDeprecatedRules":"26"},"/Users/corygallagher/Documents/node_projects/toneapp/client/src/index.js",[],["51","52"],"/Users/corygallagher/Documents/node_projects/toneapp/client/src/App.js",[],"/Users/corygallagher/Documents/node_projects/toneapp/client/src/reportWebVitals.js",[],"/Users/corygallagher/Documents/node_projects/toneapp/client/src/Characterbycharacter.js",["53","54","55","56","57","58","59","60","61"],"import React, { Component } from 'react'\nimport hark from 'hark'\n\nimport io from \"socket.io-client\"\nimport RecordRTC from \"recordrtc\"\n\nimport './App.css';\nimport './Switch.css';\n\n\nlet endpoint = \"http://localhost:5000\"\nlet socket = io.connect(`${endpoint}`)\nclass Characterbycharacter extends Component {\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      threshold_decibels: 50,\n      voice_present: false,\n      recording: false,\n      new_audio: [],\n      tones_recorded: [],\n      currentIndex: 0,\n      sentence_finished: false,\n      automatic_mode: false,\n      show_pinyin: false\n    }\n    this.state.test_sentence = this.props.sentence\n    this.recorder = null\n    this.speechEvents = null\n  }\n\n  initRecorder = (stream) => {\n      let recorder = RecordRTC(stream, {\n      type: 'audio',\n      sampleRate: 44100,\n      bufferSize: 2048,\n      numberOfAudioChannels: 1,\n      recorderType: RecordRTC.StereoAudioRecorder\n    });\n      return recorder\n  }\n\n  componentDidMount = () => {\n    socket.on('predicted_tone', data => {\n      const prediction = this.state.test_sentence.spoken_tones[data[\"index\"]] === \"_\" ? \"_\" : data[\"prediction\"].toString()\n      const newToneArray = [...this.state.tones_recorded]\n      newToneArray.splice(data[\"index\"], 1, prediction)\n      const finished = newToneArray.length === this.state.test_sentence.spoken_tones.length\n      const automatic = this.state.automatic_mode && !finished\n      const showPinyin = finished || this.state.show_pinyin\n      this.setState({tones_recorded: newToneArray, sentence_finished: finished},() => {this.checkPhrase()})\n    })\n  }\n\n  componentDidUpdate = (prevProps) => {\n    if(prevProps.sentence.phrase_order && prevProps.sentence.phrase_order !== this.props.sentence.phrase_order){\n      console.log(\"UPDATE\")\n      this.setState({test_sentence: this.props.sentence})\n    }\n  }\n\n  checkPhrase = () => {\n    console.log(this.state.tones_recorded)\n    let isCorrect = false\n    if(!this.state.sentence_finished && this.state.automatic_mode){\n      this.startRecording()\n    } else if(this.state.sentence_finished){\n      isCorrect = this.state.tones_recorded.every((tone,index) => tone === this.state.test_sentence.spoken_tones[index])    \n    }\n    console.log(isCorrect,this.state.sentence_finished, this.props.user, this.state.test_sentence.is_completed_char,this.state.test_sentence.spoken_tones)\n    if(isCorrect && this.props.user && !this.state.test_sentence.is_completed_char){\n      this.props.mutationFunction(true, this.state.test_sentence.is_completed_full)\n    }\n\n  }\n\n  saveRecording = (newAudio, blob) => {\n    newAudio.src = URL.createObjectURL(blob)\n    const previousIndex = this.state.currentIndex\n    const newAudioArray = [...this.state.new_audio]\n    newAudioArray.splice(this.state.currentIndex, 1, newAudio)\n\n    this.setState({voice_present: false, new_audio: newAudioArray, recording: false, currentIndex: previousIndex + 1}, () =>\n    {\n        socket.emit('tone_recorded', {voice_recording: blob, character_index: previousIndex, threshold: this.state.threshold_decibels});\n    })\n   \n  }\n\n  startRecording = () => {\n    let _this = this\n    var newAudio = document.getElementById(\"replay-\" + _this.state.currentIndex);\n    navigator.mediaDevices.getUserMedia({audio: true }).then(async function(stream) {\n        _this.recorder = _this.initRecorder(stream)\n        var options = {threshold: -1 * _this.state.threshold_decibels};//-100 is silence -50 is the default\n        _this.speechEvents = hark(stream, options);\n\n        _this.recorder.startRecording();\n\n        _this.speechEvents.on('speaking', function() {\n          console.log('speaking');\n          _this.setState({voice_present: true, predicted_tone: null})\n        });\n\n        _this.speechEvents.on('stopped_speaking', function() {\n          console.log('STOPPED SPEAKING');\n          _this.recorder.stopRecording(async function() {\n          _this.speechEvents.stop()\n          let blob = await _this.recorder.getBlob();\n          _this.saveRecording(newAudio,blob)\n          });\n\n        });\n        _this.setState({recording: true})\n    });\n  }\n\n  toggleMode = () => {\n    this.setState({automatic_mode: !this.state.automatic_mode})\n  }\n\n  togglePinyin = () => {\n    this.setState({show_pinyin: !this.state.show_pinyin})\n  }\n\n  replayAudio = () => {\n    if(this.state.new_audio.length){\n      this.state.new_audio[this.state.currentIndex].play()\n    }\n  }\n\n  playNativeVoice = () => {\n    const letters = this.state.test_sentence.pinyin_no_tones[this.state.currentIndex]\n    const toneNumber = this.state.test_sentence.spoken_tones[this.state.currentIndex]\n    const fileName = '/native_voice_audio/' + letters + toneNumber + '_FV1_MP3.mp3'\n    const audio = new Audio(fileName)\n    audio.play()\n  }\n\n\n  restartSentence = () => {\n    this.setState({currentIndex: 0, tones_recorded: [], sentence_finished: false, new_audio: [], recording: false, automatic_mode: false, show_pinyin: false})\n  }\n\n  handleCharClick = (index) => {\n    if(index <= this.state.tones_recorded.length){\n      this.setState({currentIndex: index})  \n    }\n  }\n\n  diplayString = (text = '', isChars = false) => {\n     const parts = text.split('')\n     return (\n       <span className=\"String-holder charByChar\">\n         {parts.map((char,index)=> {\n           if(isChars && index === this.state.currentIndex){\n             return <mark key={index} onClick={() => this.handleCharClick(index)}>{char}</mark>\n           } else if(!isChars && index <= this.state.tones_recorded.length -1 && this.state.test_sentence.spoken_tones[index] == this.state.tones_recorded[index]) {\n             return <mark style={{\"backgroundColor\": \"green\"}}key={index} onClick={() => this.handleCharClick(index)}>{char}</mark>\n           } else if(!isChars && index <= this.state.tones_recorded.length -1 && this.state.test_sentence.spoken_tones[index] != this.state.tones_recorded[index]) {\n             return <mark style={{\"backgroundColor\": \"red\"}}key={index} onClick={() => this.handleCharClick(index)}>{char}</mark>\n           } else{\n             return <span key={index} onClick={() => this.handleCharClick(index)}>{char}</span>\n           }\n\n         })}\n      </span>\n     )\n  }\n\n  recordingButtonClick = () => {\n    let _this = this\n    if(_this.state.recording){\n      _this.setState({automatic_mode: false, recording: false}, ()=> {\n        _this.state.recorder.stopRecording(async function() {\n          _this.state.harkObject.stop()\n        });\n      })\n    } else{\n      _this.startRecording()\n    }\n  }\n\n  render(){\n    let btn_class = this.state.recording ? \"pressedButton\" : \"defaultButton\";\n    const spoken_tones = this.state.sentence_finished ? this.state.test_sentence.spoken_tones : ''\n    return (\n      <div>\n        {\n          this.state.test_sentence.characters.split('').map((recording, index)=> {\n            return <audio key={index} id={\"replay-\" + index}/>\n          })\n        }\n        <div style={{display: \"inline-flex\", flexDirection: \"column\"}}>\n          <p style={{\"textAlign\": \"center\", height: \"1vh\"}}>{this.state.show_pinyin && this.state.test_sentence.pinyin}</p>\n          <span className={\"circle \" + (this.props.isComplete() ? \"\" : \"hide\")}/>  \n          <span style={{\"textAlign\": \"center\"}}>{this.state.test_sentence.display}</span>\n          {/*this.diplayString(spoken_tones, false)*/}\n          {this.diplayString(this.state.test_sentence.characters, true)}\n          {this.diplayString(this.state.tones_recorded.join(''), false)}\n        </div>\n        <div style={{display: \"flex\", flexDirection: \"row\", justifyContent: \"center\", \"marginTop\": \"20px\", \"marginBottom\": \"20px\"}}>\n        <button className=\"tooltip\" disabled={this.state.currentIndex >= this.state.test_sentence.spoken_tones.length} onClick={this.recordingButtonClick}>\n          <img style={{\"padding\": \"0\",\"height\":  \"7vh\", \"width\":  \"4vw\"}}src=\"/record-voice-button.svg\" />\n          <span className=\"tooltiptext\">Record voice</span>\n        </button>\n        <button className=\"tooltip\" disabled={this.state.currentIndex >=this.state.tones_recorded.length}  onClick={this.replayAudio}>\n          <img style={{\"padding\": \"0\",\"height\":  \"7vh\", \"width\":  \"4vw\"}}src=\"/play-button.svg\" />\n          <span className=\"tooltiptext\">Replay recording for selected character</span>\n        </button>\n         <button className=\"tooltip\" disabled={this.state.tones_recorded.length === 0} onClick={this.restartSentence}>\n              <img style={{\"padding\": \"0\",\"height\":  \"7vh\", \"width\":  \"4vw\"}}src=\"/delete-button.svg\" />\n              <span className=\"tooltiptext\">Restart phrase</span>\n        </button>\n        </div>\n         <button  className=\"defaultButton\"  disabled={this.state.test_sentence.spoken_tones[this.state.currentIndex] === '_' || this.state.currentIndex >= this.state.test_sentence.spoken_tones.length} onClick={this.playNativeVoice}>\n                  Play Native Speaker Audio\n        </button>\n        <div style={{display: \"flex\", flexDirection: \"column\", justifyContent: \"center\"}}>\n          <p style={{\"height\": \"25px\"}}>{this.state.voice_present ? \"Voice heard\" : this.state.recording ?  \"Recording...\" : \"\"}</p>\n          <div style={{display: \"flex\", flexDirection: \"row\", justifyContent: \"center\", \"marginTop\": \"20px\"}}>\n            <p className=\"tooltip\" style={{fontSize: \"14px\", \"marginBlockStart\": \"-1.5em\", \"marginRight\": \"20px\", \"width\": \"50px\"}}>{\"Manual Mode\"}\n            <span className=\"tooltiptext\">User must press the record button for each character</span>\n            </p> \n            <label className=\"switch\">\n              <input type=\"checkbox\" checked={this.state.automatic_mode} onChange={this.toggleMode} />\n              <span className=\"slider round\"></span>\n            </label>\n           <p className=\"tooltip\" style={{fontSize: \"14px\", \"width\": \"50px\", \"marginBlockStart\": \"-1.5em\", \"marginLeft\": \"3%\"}}>{\"Automatic Mode\"}\n           <span className=\"tooltiptext\">Recording will restart automatically after selected chaaracter changes</span>\n           </p>\n           </div>\n           <div style={{display: \"flex\", flexDirection: \"row\", justifyContent: \"center\", \"marginTop\": \"20px\"}}>\n           <p style={{fontSize: \"14px\", \"marginBlockStart\": \"-1.5em\", \"marginRight\": \"20px\", \"width\": \"50px\"}}>{\"Hide Pinyin\"}</p>\n            <label className=\"switch\">\n              <input type=\"checkbox\" checked={this.state.show_pinyin} onChange={this.togglePinyin} />\n              <span className=\"slider round\"></span>\n            </label>\n           <p style={{fontSize: \"14px\", \"width\": \"50px\", \"marginBlockStart\": \"-1.5em\", \"marginLeft\": \"3%\"}}>{\"Show Pinyin\"}</p>\n          </div>\n         </div>\n      </div>\n    );\n  }\n}\n\nexport default Characterbycharacter;\n","/Users/corygallagher/Documents/node_projects/toneapp/client/src/Fullsentence.js",["62","63","64","65","66","67","68","69","70","71","72"],"import React, { Component } from 'react'\nimport {Howl} from 'howler';\n\nimport hark from 'hark'\nimport {strings} from './constants'\n\nimport io from \"socket.io-client\"\nimport RecordRTC from \"recordrtc\"\n\nimport './App.css';\nimport './Switch.css';\n\n\nlet endpoint = \"http://localhost:5000\"\nlet socket = io.connect(`${endpoint}`)\nclass Fullsentence extends Component {\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      threshold_decibels: 50,\n      milliseconds: 0,\n      voice_present: false,\n      is_recording: false,\n      is_playing: false,\n      is_paused: false,\n      sentence_finished: false,\n      currentIndex: null,\n      character_offsets: [],\n      tones_recorded: [],\n      show_pinyin: false\n    }\n    this.state.test_sentence = this.props.sentence\n    this.audioProgress = React.createRef();\n    this.requestRef = React.createRef();\n    this.howler = null\n    this.recorder = null\n    this.speechEvents = null\n  }\n\n  componentDidMount = () => {\n    socket.on('predicted_tone', data => {\n      const prediction = this.state.test_sentence.spoken_tones[data[\"index\"]] === \"_\" ? \"_\" : data[\"prediction\"].toString()\n      const newToneArray = [...this.state.tones_recorded, prediction]\n      this.setState({tones_recorded: newToneArray},() => {this.checkPhrase()})\n    })\n  }\n\n  checkPhrase = () => {\n    let isCorrect = false\n    if(this.state.sentence_finished){\n      isCorrect = this.state.tones_recorded.every((tone,index) => tone === this.state.test_sentence.spoken_tones[index])    \n    }\n    if(isCorrect && this.props.user && !this.state.test_sentence.is_completed_full){\n      this.props.mutationFunction(this.state.test_sentence.is_completed_char, true)\n    }\n  }\n\n\n  componentDidUpdate = (prevProps) => {\n    if(prevProps.sentence.phrase_order && prevProps.sentence.phrase_order !== this.props.sentence.phrase_order){\n      this.setState({test_sentence: this.props.sentence})\n    }\n  }\n\n  initRecorder = (stream) => {\n      let recorder = RecordRTC(stream, {\n      type: 'audio',\n      sampleRate: 44100,\n      bufferSize: 2048,\n      numberOfAudioChannels: 1,\n      recorderType: RecordRTC.StereoAudioRecorder\n    });\n      return recorder\n  }\n\n  startRecording = () => {\n    let _this = this\n    navigator.mediaDevices.getUserMedia({audio: true }).then(async function(stream) {\n        _this.recorder = _this.initRecorder(stream)\n        var options = {threshold: -1 * _this.state.threshold_decibels};//-100 is silence -50 is the default\n        _this.speechEvents = hark(stream, options);\n\n        _this.recorder.startRecording();\n\n        _this.speechEvents.on('speaking', function() {\n          console.log('speaking');\n          _this.setState({voice_present: true})\n        });\n\n        _this.speechEvents.on('stopped_speaking', function() {\n          console.log('STOPPED SPEAKING');\n          _this.recorder.stopRecording(async function() {\n          _this.speechEvents.stop()\n          let blob = await _this.recorder.getBlob()\n          socket.emit('phrase_recorded', {voice_recording: blob});\n          _this.howler = new Howl({\n            src: [URL.createObjectURL(blob)],\n            onplay: function(){\n              console.log(\"PLAY\")\n              _this.setState({is_paused: false, milliseconds: 0})\n            },\n            onpause: function(){\n              _this.setState({is_playing: false, is_paused: true, milliseconds: _this.audioProgress.current.valueAsNumber}, ()=> {cancelAnimationFrame(_this.requestRef.current)})\n            },\n            onend: function(){\n              _this.setState({is_playing: false, milliseconds: _this.audioProgress.current.valueAsNumber})\n            },\n            onload: function(){\n              var audioSlider = document.getElementById(\"audio-slider\")\n              audioSlider.min = 0\n              audioSlider.max = this.duration() * 1000\n              audioSlider.value = 0\n            },             \n            format:[\"wav\"]\n          });\n          _this.setState({voice_present: false, audio_blob: blob, is_recording: false})\n          });\n\n        });\n        _this.setState({is_recording: true})\n    });\n  }\n\n  setSprites = (minValue, currentValue, maxValue) => {\n     this.howler._sprite = {\n      \"before\" : [minValue, currentValue-minValue], \n      \"after\" : [currentValue, maxValue-currentValue],\n      \"all\" : [minValue, maxValue-minValue]\n    }\n\n    this.state.character_offsets.forEach((char, index) => {\n      this.howler._sprite[index.toString()] = [char.begin, char.end]\n    })\n  }\n\n  replayAudio = (spriteName) => {\n    if(this.howler != null){\n      //const minimum = this.state.character_offsets.length ? this.state.character_offsets[this.state.character_offsets.length -1] : 0\n      const minimum = parseInt(this.audioProgress.current.min)\n      const maximum = parseInt(this.audioProgress.current.max)\n      const currentValue = parseInt(this.audioProgress.current.valueAsNumber)\n\n      this.setSprites(minimum, currentValue, maximum)\n      this.howler.play(spriteName)\n    }\n  }\n\n  pauseAudio = () => {\n    if(this.howler != null){\n      this.howler.pause();\n    }\n  }\n\n  restartSentence = () => {\n    this.howler = null\n    this.setState({ milliseconds: 0, tones_recorded: [], character_offsets: [], currentIndex: null, show_pinyin: false, sentence_finished: false})\n  }\n\n  playWithSlider = () => {\n      let start = Date.now();\n      let audioSlider = document.getElementById(\"audio-slider\")\n      let startPoint = this.audioProgress.current.valueAsNumber\n      this.replayAudio(strings.AFTER)\n      let _this = this\n      _this.requestRef.current = requestAnimationFrame(function animateSlider() {\n          let interval = Date.now() - start + startPoint\n          audioSlider.value = interval\n          if (interval < parseInt(audioSlider.max)) _this.requestRef.current = requestAnimationFrame(animateSlider); // queue request for next frame\n      });\n  }\n\n  updateTime = () => {\n    this.setState({milliseconds: this.audioProgress.current.valueAsNumber})\n  }\n\n  getTone = () => {\n    socket.emit('cut_phrase', {begin: parseInt(this.audioProgress.current.min), end: parseInt(this.audioProgress.current.valueAsNumber), \"character_index\": this.state.tones_recorded.length});\n    const finished = this.state.tones_recorded.length === this.state.test_sentence.spoken_tones.length - 1\n    const showPinyin = finished || this.state.show_pinyin\n    let _this = this\n    this.setState(prevState => ({character_offsets: [...prevState.character_offsets, {begin: parseInt(this.audioProgress.current.min), end: parseInt(this.audioProgress.current.valueAsNumber) - parseInt(this.audioProgress.current.min)}], sentence_finished: finished, show_pinyin: showPinyin}), ()=>{\n      _this.setSprites(parseInt(this.audioProgress.current.valueAsNumber), parseInt(this.audioProgress.current.valueAsNumber), parseInt(this.audioProgress.current.max))\n      var audioSlider = document.getElementById(\"audio-slider\")\n      audioSlider.max = this.audioProgress.current.max\n      audioSlider.min = this.audioProgress.current.valueAsNumber\n      audioSlider.value = this.audioProgress.current.valueAsNumber\n    })\n  }\n\n  handleCharClick = (index) => {\n    let _this = this\n    if(index < this.state.tones_recorded.length){\n      this.setState({currentIndex: index}, ()=> {_this.howler.play(index.toString())})  \n    }\n  }\n\n  diplayString = (text = '', isChars = false) => {\n     const parts = text.split('')\n     return (\n       <span className=\"String-holder\">\n         {parts.map((char,index)=> {\n           if(isChars && index === this.state.currentIndex){\n             return <mark key={index} onClick={() => this.handleCharClick(index)}>{char}</mark>\n           } else if(!isChars && index <= this.state.tones_recorded.length -1 && this.state.test_sentence.spoken_tones[index] == this.state.tones_recorded[index]) {\n             return <mark style={{\"backgroundColor\": \"green\"}}key={index} onClick={() => this.handleCharClick(index)}>{char}</mark>\n           } else if(!isChars && index <= this.state.tones_recorded.length -1 && this.state.test_sentence.spoken_tones[index] != this.state.tones_recorded[index]) {\n             return <mark style={{\"backgroundColor\": \"red\"}}key={index} onClick={() => this.handleCharClick(index)}>{char}</mark>\n           } else{\n             return <span key={index} onClick={() => this.handleCharClick(index)}>{char}</span>\n           }\n\n         })}\n      </span>\n     )\n  }\n\n  displaySlider = (shouldDisplay) => {\n    return (\n      <div style={{\"height\": \"3vh\"}}>\n      {shouldDisplay && (\n        <div>\n          <button className=\"defaultButton tooltip\" onClick={() => this.replayAudio(strings.BEFORE)}>\n            <img style={{\"padding\": \"0\",\"height\":  \"3vh\", \"width\":  \"2vw\"}}src=\"/play-button.svg\" />\n            <span className=\"tooltiptext\">Play audio left of cursor</span>\n          </button>\n          <input style={{\"width\": \"65%\"}} id=\"audio-slider\" ref={this.audioProgress} type=\"range\" onChange={this.updateTime} />\n          <button  className=\"defaultButton tooltip\" onClick={() => this.replayAudio(strings.AFTER)}>\n            <img style={{\"padding\": \"0\",\"height\":  \"3vh\", \"width\":  \"2vw\"}}src=\"/play-button.svg\" />\n            <span className=\"tooltiptext\">Play audio right of cursor</span>\n          </button> \n        </div>)}\n      </div>\n     )\n  }\n\n  togglePinyin = () => {\n    this.setState({show_pinyin: !this.state.show_pinyin})\n  }\n\n  undoLastTone = () => {\n    let character_offsets = [...this.state.character_offsets]\n    const lastRecording = character_offsets.pop()\n    const tones_recorded = [...this.state.tones_recorded]\n    tones_recorded.pop()\n    console.log(character_offsets, lastRecording)\n    let _this = this\n    this.setState(prevState => ({character_offsets: character_offsets, tones_recorded: tones_recorded, milliseconds: lastRecording.begin, sentence_finished: false, show_pinyin: prevState.show_pinyin}), ()=>{\n      _this.setSprites(parseInt(lastRecording.begin), parseInt(lastRecording.begin), parseInt(this.audioProgress.current.max))\n      var audioSlider = document.getElementById(\"audio-slider\")\n      audioSlider.max = this.audioProgress.current.max\n      audioSlider.min = lastRecording.begin\n      audioSlider.value = lastRecording.begin\n    })\n    \n  }\n\n  render(){\n    //const btn_class = this.state.is_recording ? \"pressedButton\" : \"defaultButton\";\n    const spoken_tones = this.state.sentence_finished ? this.state.test_sentence.spoken_tones : ''\n    const btns_disabled = this.howler == null\n    console.log(this.state)\n    return (\n          <div>\n            <audio id=\"replay\"/>\n            <div style={{display: \"inline-flex\", flexDirection: \"column\"}}>\n              <p style={{\"textAlign\": \"center\", height: \"1vh\"}}>{this.state.show_pinyin && this.state.test_sentence.pinyin}</p>\n              <span className={\"circle \" + (this.props.isComplete() ? \"\" : \"hide\")}/>  \n              <span style={{\"textAlign\": \"center\"}}>{this.state.test_sentence.display}</span>\n              {/*this.diplayString(spoken_tones, false)*/}\n              {this.diplayString(this.state.test_sentence.characters, true)}\n              {this.diplayString(this.state.tones_recorded.join(''), false)}\n            </div>\n            <p style={{\"height\": \"3vh\"}}>{this.state.voice_present ? \"Voice heard\" : this.state.is_recording ?  \"Recording...\" : \"\"}</p>\n            <p style={{\"height\": \"3vh\"}}>{this.state.milliseconds ? (this.state.milliseconds/1000) + \" Seconds\" : null}</p>\n            {this.displaySlider(this.howler != null)}\n            <div style={{display: \"flex\", flexDirection: \"row\", justifyContent: \"center\", \"marginTop\": \"4vh\"}}>\n              <button className=\"tooltip\" style={{backgroundColor: this.state.is_recording ? \"darkgray\": \"white\"}} onClick={this.startRecording}>\n                <img style={{\"padding\": \"0\",\"height\":  \"7vh\", \"width\":  \"4vw\"}}src=\"/record-voice-button.svg\" />\n                <span className=\"tooltiptext\">Record voice</span>\n              </button>\n              <button className=\"tooltip\" disabled={btns_disabled}  onClick={()=> this.setState({is_playing: true}, ()=>{this.playWithSlider()})}>\n                <img style={{\"padding\": \"0\",\"height\":  \"7vh\", \"width\":  \"4vw\"}}src=\"/play-button.svg\" />\n                <span className=\"tooltiptext\">Play audio (cursor will advance)</span>\n              </button>\n              <button  className=\"tooltip\" disabled={btns_disabled || !this.state.is_playing} onClick={this.pauseAudio}>\n                    <img style={{\"padding\": \"0\",\"height\":  \"7vh\", \"width\":  \"4vw\"}}src=\"/pause-button.svg\" />\n                    <span className=\"tooltiptext\">Pause audio (cursor will stop)</span>\n              </button>\n              <button   className=\"tooltip\" disabled={btns_disabled} onClick={() => this.replayAudio(strings.ALL)}>\n                    <img style={{\"padding\": \"0\",\"height\":  \"7vh\", \"width\":  \"4vw\"}}src=\"/replay-button.svg\" />\n                    <span className=\"tooltiptext\">Play entire remaining audio(cursor will not move)</span>\n              </button>\n               <button  className=\"tooltip\" disabled={btns_disabled} onClick={this.undoLastTone}>\n                    <img style={{\"padding\": \"0\",\"height\":  \"7vh\", \"width\":  \"4vw\"}}src=\"/backspace-button.svg\" />\n                    <span className=\"tooltiptext\">Undo last audio cut</span>\n              </button>\n               <button  className=\"tooltip\" disabled={btns_disabled} onClick={this.restartSentence}>\n                    <img style={{\"padding\": \"0\",\"height\":  \"7vh\", \"width\":  \"4vw\"}}src=\"/delete-button.svg\" />\n                    <span className=\"tooltiptext\">Restart sentence</span>\n              </button>\n              <button  className=\"tooltip\" disabled={btns_disabled} onClick={this.getTone}>\n                    <span className=\"tooltiptext\">Get tone of audio left of the cursor</span>\n                    Get Tone \n              </button>\n             </div>\n             <div style={{display: \"flex\", flexDirection: \"row\", justifyContent: \"center\", \"marginTop\": \"8vh\"}}>\n             <p style={{fontSize: \"14px\", \"marginBlockStart\": \"-1.5em\", \"marginRight\": \"20px\", \"width\": \"50px\"}}>{\"Hide Pinyin\"}</p>\n              <label className=\"switch\">\n                <input type=\"checkbox\" checked={this.state.show_pinyin} onChange={this.togglePinyin} />\n                <span className=\"slider round\"></span>\n              </label>\n             <p style={{fontSize: \"14px\", \"width\": \"50px\", \"marginBlockStart\": \"-1.5em\", \"marginLeft\": \"3%\"}}>{\"Show Pinyin\"}</p>\n            </div>\n        </div>\n\n    );\n  }\n}\n\nexport default Fullsentence;","/Users/corygallagher/Documents/node_projects/toneapp/client/src/constants.js",[],"/Users/corygallagher/Documents/node_projects/toneapp/client/src/Header.js",[],"/Users/corygallagher/Documents/node_projects/toneapp/client/src/Login.js",[],"/Users/corygallagher/Documents/node_projects/toneapp/client/src/utils.js",[],"/Users/corygallagher/Documents/node_projects/toneapp/client/src/Learn.js",["73","74","75"],"import { useState, useRef} from 'react'\nimport Characterbycharacter from './Characterbycharacter'\nimport Fullsentence from './Fullsentence'\nimport { useQuery, useMutation } from  'react-apollo';\nimport gql from 'graphql-tag';\nimport { redirectToLearnComponent} from './utils'\nimport { useParams } from \"react-router-dom\";\nimport { GET_PHRASES } from './Dashboard'\n\nconst UPDATE_PROGRESS = gql`\nmutation updateProgress($deck_id: Int!, $phrase_order: Int!, $is_completed_char: Boolean!, $is_completed_full: Boolean!) {\n  setPhraseLearned(deck_id: $deck_id, phrase_order: $phrase_order, is_completed_char: $is_completed_char, is_completed_full: $is_completed_full){\n    is_completed_char\n    is_completed_full\n  }\n}\n`\n\nconst Learn = (props) => {\n  console.log(props)\n\n  const [fullSentenceMode, setSentenceMode] = useState(props.location.state.isFullSentenceMode);\n\n  const { deckId, phraseOrder } = useParams();\n  const characterByCharacterRef = useRef();\n  const fullSentenceRef = useRef();\n\n  const { loading, error, data } = useQuery(GET_PHRASES, {\n    variables: {deck_id: parseInt(deckId)}\n  });\n\n  const [updateProgress, { mutationData }] = useMutation(UPDATE_PROGRESS)\n\n  if (loading) return 'Loading...';\n  if (error) return `Error! ${error.message}`;\n\n  function changeMode(isFullSentenceMode){\n    setSentenceMode(isFullSentenceMode)\n  }\n\n  function getPhraseDetails(phrase){\n    console.log(phrase)\n    let phrase_data = {}\n    phrase_data[\"deck_id\"] = parseInt(deckId)\n    phrase_data[\"phrase_order\"] = parseInt(phraseOrder)\n    phrase_data[\"display\"] = phrase.full_phrase\n    phrase_data[\"characters\"] = phrase.phrase_no_punctuation\n    phrase_data[\"pinyin\"] = phrase.pinyin.join(\" \")\n    phrase_data[\"spoken_tones\"] = phrase.spoken_tones.join(\"\").replaceAll(\"5\",\"_\")\n    phrase_data[\"pinyin_no_tones\"] = phrase.pinyin_no_tones\n    phrase_data[\"phrase_order\"] = phrase.phrase_order\n    phrase_data[\"is_completed_char\"] = phrase.is_completed_char || false\n    phrase_data[\"is_completed_full\"] = phrase.is_completed_full || false\n    console.log(phrase_data)\n    return phrase_data\n  }\n\n  function onClickEvent(deck_id, phrase_order){\n    if(fullSentenceMode){\n      fullSentenceRef.current.restartSentence()\n    }else{\n      characterByCharacterRef.current.restartSentence()\n    }\n    redirectToLearnComponent(props, deck_id, phrase_order, fullSentenceMode)\n  }\n\n  function submitCorrect(is_completed_char, is_completed_full){\n    updateProgress({variables:{deck_id: parseInt(deckId), phrase_order: parseInt(phraseOrder), is_completed_char: is_completed_char, is_completed_full: is_completed_full}, \n      update: (store)=> {\n        const dashboardData = store.readQuery({ query: GET_PHRASES, variables: { deck_id: parseInt(deckId) } })\n        dashboardData.getPhrasesInDeck[phraseOrder - 1][\"is_completed_char\"] = is_completed_char\n        dashboardData.getPhrasesInDeck[phraseOrder - 1][\"is_completed_full\"] = is_completed_full\n        console.log(dashboardData)\n        store.writeQuery({\n          query: GET_PHRASES,\n          dashboardData\n        })\n     }})    \n  }\n\n  function checkComplete(){\n    return ((data.getPhrasesInDeck[phraseOrder - 1][\"is_completed_char\"] && !fullSentenceMode) || (data.getPhrasesInDeck[phraseOrder - 1][\"is_completed_full\"] && fullSentenceMode))\n  }\n\n  return(\n    <div className=\"LearnContainer\">\n      <div className=\"Navbar\">\n        <p className={!fullSentenceMode ? \"selectedItem\": \"\"} onClick={() => changeMode(false)}>Character by Character</p>\n        <p className={fullSentenceMode ? \"selectedItem\": \"\"} onClick={() => changeMode(true)}>Full Phrase</p>\n      </div>\n      \n      <div className=\"toneTrainingInterface\">\n      <button className=\"tooltip\" disabled={phraseOrder=== \"1\" } style={{marginRight: \"5%\"}}  onClick={() => onClickEvent(deckId,  parseInt(phraseOrder) - 1)}>\n        <img style={{\"padding\": \"0\",\"height\":  \"7vh\", \"width\":  \"4vw\"}}src=\"/left-arrow-button.svg\" />\n        <span class=\"tooltiptext\">Previous phrase</span>\n      </button>\n      <div style={{width: \"75%\"}}>\n      {fullSentenceMode ? <Fullsentence ref={fullSentenceRef} isComplete={checkComplete} user={data.me} sentence={getPhraseDetails(data.getPhrasesInDeck[phraseOrder - 1])} mutationFunction={submitCorrect} />: <Characterbycharacter ref={characterByCharacterRef} isComplete={checkComplete} user={data.me} sentence={getPhraseDetails(data.getPhrasesInDeck[phraseOrder - 1])} mutationFunction={submitCorrect}/>}\n      </div>\n      <button className=\"tooltip\" disabled={parseInt(phraseOrder) === data.getPhrasesInDeck.length } style={{marginLeft: \"5%\"}} onClick={() => onClickEvent(deckId, parseInt(phraseOrder) + 1)}>\n        <img style={{\"padding\": \"0\",\"height\":  \"7vh\", \"width\":  \"4vw\"}}src=\"/right-arrow-button.svg\" />\n        <span style={{\"left\": \"inherit\", \"right\": \"105%\"}} class=\"tooltiptext\">Next phrase</span>\n      </button>\n      </div>\n    </div>\n  )\n    \n}\nexport default Learn","/Users/corygallagher/Documents/node_projects/toneapp/client/src/Dashboard.js",["76","77"],"import React, { Component } from 'react'\nimport {Query} from 'react-apollo';\nimport gql from 'graphql-tag';\nimport { redirectToLearnComponent} from './utils'\nimport { Link} from 'react-router-dom'\n\nconst GET_DECKS = gql`\nquery getDeckList {\n  getDecks {\n    deck_id\n    deck_name\n  }\n}\n`\nexport const GET_PHRASES = gql`\nquery getPhraseList($deck_id: Int!) {\n  me {\n    _id\n    user_name\n    user_role\n    user_password\n  }\n  getPhrasesInDeck(deck_id: $deck_id) {\n    _id\n    phrase_order\n    full_phrase\n    phrase_no_punctuation\n    word_list\n    pinyin\n    pinyin_no_tones\n    written_tones\n    spoken_tones\n    is_completed_char\n    is_completed_full\n  }\n}\n`\n\nclass Dashboard extends Component {\n  state = {\n    deckIndexSelected: null\n  }\n\n  selectMenuItem = (index) => {\n    this.setState(prevState => ({deckIndexSelected: prevState.deckIndexSelected  === index ? null : index}));\n  }\n\n  getPhraseList = (deck_id) => {\n    return(\n      <Query query={GET_PHRASES} variables={{deck_id: deck_id}}>\n      {({ loading, error, data, refetch }) => {\n        if (loading) return <div>Fetching</div>\n        if (error) return <div>error</div>\n        return (\n          <div className=\"menuSubItemContainer\">\n          {data.getPhrasesInDeck.map((phrase)=>\n            <div className=\"menuSubItem\">\n            <span style={{ display: \"inlineBlock\", minWidth: \"50%\"}}>{phrase.full_phrase}</span>\n            <Link className=\"menuSubItemLink tooltip\"\n              to={{\n                pathname: \"/learn/\" + deck_id + \"/\" + phrase.phrase_order,\n                state: { isFullSentenceMode: false }\n              }}\n            >\n            Char Mode\n            <span class=\"tooltiptext\">Practice each character separately</span>\n            </Link>\n            <span className={\"circle \" + ((phrase.spoken_tones.length > 1 && phrase.is_completed_full) || phrase.is_completed_char ? \"\" : \"hide\")}/>\n            <Link className=\"menuSubItemLink tooltip\"\n              to={{\n                pathname: \"/learn/\" + deck_id + \"/\" + phrase.phrase_order,\n                state: { isFullSentenceMode: true }\n              }}\n            >\n            Full Mode\n            <span class=\"tooltiptext\">Practice entire phrase</span>\n            </Link>\n             <span className={\"circle \" + ((phrase.spoken_tones.length == 1 && phrase.is_completed_char) || phrase.is_completed_full ? \"\" : \"hide\")}/>     \n            </div>\n          )}\n          </div>\n        )\n      }}\n      </Query>\n    )\n  }\n\n  render() {\n    return(\n      <Query query={GET_DECKS}>\n      {({ loading, error, data, refetch }) => {\n        if (loading) return <div>Fetching</div>\n        if (error) return <div>error</div>\n        return(\n          <div className=\"menuContainer\">\n            <div className=\"menuHeader\">\n            <p style={{\"marginLeft\": \"10%\", \"fontSize\": \"2vw\"}}>Decks</p>\n            </div>\n            <div className=\"menuList\">\n              {data.getDecks.map((deck, index)=>\n                <div className=\"menuItem\" onClick={() => this.selectMenuItem(index)}>\n                  <p>{deck.deck_name}</p>\n                  <span className={index === this.state.deckIndexSelected ? \"chevron bottom\": \"chevron top\"}/>\n                </div>\n               )}\n              {this.state.deckIndexSelected !== null && this.getPhraseList(1)}\n             </div>\n          </div>\n        )\n      }}\n      </Query>\n    )\n  }\n\n}\n\nexport default Dashboard",{"ruleId":"78","replacedBy":"79"},{"ruleId":"80","replacedBy":"81"},{"ruleId":"82","severity":1,"message":"83","line":50,"column":13,"nodeType":"84","messageId":"85","endLine":50,"endColumn":22},{"ruleId":"82","severity":1,"message":"86","line":51,"column":13,"nodeType":"84","messageId":"85","endLine":51,"endColumn":23},{"ruleId":"87","severity":1,"message":"88","line":159,"column":127,"nodeType":"89","messageId":"90","endLine":159,"endColumn":129},{"ruleId":"87","severity":1,"message":"91","line":161,"column":127,"nodeType":"89","messageId":"90","endLine":161,"endColumn":129},{"ruleId":"82","severity":1,"message":"92","line":186,"column":9,"nodeType":"84","messageId":"85","endLine":186,"endColumn":18},{"ruleId":"82","severity":1,"message":"93","line":187,"column":11,"nodeType":"84","messageId":"85","endLine":187,"endColumn":23},{"ruleId":"94","severity":1,"message":"95","line":205,"column":11,"nodeType":"96","endLine":205,"endColumn":107},{"ruleId":"94","severity":1,"message":"95","line":209,"column":11,"nodeType":"96","endLine":209,"endColumn":99},{"ruleId":"94","severity":1,"message":"95","line":213,"column":15,"nodeType":"96","endLine":213,"endColumn":105},{"ruleId":"87","severity":1,"message":"88","line":205,"column":127,"nodeType":"89","messageId":"90","endLine":205,"endColumn":129},{"ruleId":"87","severity":1,"message":"91","line":207,"column":127,"nodeType":"89","messageId":"90","endLine":207,"endColumn":129},{"ruleId":"94","severity":1,"message":"95","line":224,"column":13,"nodeType":"96","endLine":224,"endColumn":101},{"ruleId":"94","severity":1,"message":"95","line":229,"column":13,"nodeType":"96","endLine":229,"endColumn":101},{"ruleId":"82","severity":1,"message":"93","line":260,"column":11,"nodeType":"84","messageId":"85","endLine":260,"endColumn":23},{"ruleId":"94","severity":1,"message":"95","line":279,"column":17,"nodeType":"96","endLine":279,"endColumn":113},{"ruleId":"94","severity":1,"message":"95","line":283,"column":17,"nodeType":"96","endLine":283,"endColumn":105},{"ruleId":"94","severity":1,"message":"95","line":287,"column":21,"nodeType":"96","endLine":287,"endColumn":110},{"ruleId":"94","severity":1,"message":"95","line":291,"column":21,"nodeType":"96","endLine":291,"endColumn":111},{"ruleId":"94","severity":1,"message":"95","line":295,"column":21,"nodeType":"96","endLine":295,"endColumn":114},{"ruleId":"94","severity":1,"message":"95","line":299,"column":21,"nodeType":"96","endLine":299,"endColumn":111},{"ruleId":"82","severity":1,"message":"97","line":32,"column":28,"nodeType":"84","messageId":"85","endLine":32,"endColumn":40},{"ruleId":"94","severity":1,"message":"95","line":94,"column":9,"nodeType":"96","endLine":94,"endColumn":103},{"ruleId":"94","severity":1,"message":"95","line":101,"column":9,"nodeType":"96","endLine":101,"endColumn":104},{"ruleId":"82","severity":1,"message":"98","line":4,"column":10,"nodeType":"84","messageId":"85","endLine":4,"endColumn":34},{"ruleId":"87","severity":1,"message":"88","line":78,"column":72,"nodeType":"89","messageId":"90","endLine":78,"endColumn":74},"no-native-reassign",["99"],"no-negated-in-lhs",["100"],"no-unused-vars","'automatic' is assigned a value but never used.","Identifier","unusedVar","'showPinyin' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Expected '!==' and instead saw '!='.","'btn_class' is assigned a value but never used.","'spoken_tones' is assigned a value but never used.","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","'mutationData' is assigned a value but never used.","'redirectToLearnComponent' is defined but never used.","no-global-assign","no-unsafe-negation"]